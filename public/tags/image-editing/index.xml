<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Image Editing on The Wizard&#39;s Manse</title>
    <link>http://thewizardsmanse.com/tags/image-editing/index.xml</link>
    <description>Recent content in Image Editing on The Wizard&#39;s Manse</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2017 The Wizard&#39;s Manse.</copyright>
    <atom:link href="http://thewizardsmanse.com/tags/image-editing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Image Processing Part 2</title>
      <link>http://thewizardsmanse.com/image-processing-part-2/</link>
      <pubDate>Sat, 02 Feb 2013 21:25:11 +0000</pubDate>
      
      <guid>http://thewizardsmanse.com/image-processing-part-2/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;http://www.thewizardsmanse.com/image-processing-part-1/&#34; title=&#34;Image Processing Part 1&#34;&gt;Image Processing Part 1&lt;/a&gt; I talked about methods for manipulation image data. If you tried out the &lt;a href=&#34;https://github.com/nathanrobinson/ImageTextEncoder&#34; title=&#34;ImageTextEncoder&#34; target=&#34;_blank&#34;&gt;code&lt;/a&gt; then you might have noticed it ran really slow.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Usually, when working with image data it is easier to conceptualize pixel locations in x,y coordinates. I used a System.Drawing.Bitmap to hold the image data, which provides the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.getpixel.aspx&#34; title=&#34;GetPixel&#34; target=&#34;_blank&#34;&gt;GetPixel&lt;/a&gt; and &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.setpixel.aspx&#34; title=&#34;SetPixel&#34; target=&#34;_blank&#34;&gt;SetPixel&lt;/a&gt; methods to access pixels using x,y coordinates. Unfortunately, this method is extremely slow. When we call this method repeatedly it causes the application to become noticeably sluggish.&lt;/p&gt;

&lt;p&gt;Luckily, there is another way to manipulate pixel data. If we can convert our x,y coordinates into an array notation, then we can call &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/5ey6h79d.aspx&#34; title=&#34;LockBits&#34; target=&#34;_blank&#34;&gt;LockBits&lt;/a&gt; and access the raw data without any noticeable slowdown.&lt;/p&gt;

&lt;p&gt;The array that is set by LockBits includes the color components of each pixel as defined by the ImageFormat. To find the location of a pixel in the array, you have to multiply the x coordinate by the width of the image an the width of the pixel data. The Bitmap object has a property called Stride which represents the width of the image multiplied by the number of bytes per pixel. You can calculate the array index of a pixel as (x * bitmap.Stride) + y.&lt;/p&gt;

&lt;p&gt;When we were using GetPixel and SetPixel, we had to convert the array position of the text into an x,y coordinate for the image. No, instead of converting it back, we can just go straight to the array.&lt;/p&gt;

&lt;pre class=&#34;brush: csharp; title: ; notranslate&#34; title=&#34;&#34;&gt;var bitmapData = image.LockBits( 
                new Rectangle(0, 0, image.Width, image.Height), 
                ImageLockMode.ReadWrite,
                image.PixelFormat);
            
            int length  = Math.Abs(bitmapData.Stride) * image.Height;
            var rgbValues = new byte[length];
            
            System.Runtime.InteropServices.Marshal.Copy(bitmapData.Scan0, rgbValues, 0, length);

            for (var c = 0; c &amp;lt; byteList.Count; c++)
            {
                if(!FastComputePixel(rgbValues, byteList, c, pixelsPerChar, Math.Abs(bitmapData.Stride) / bitmapData.Width))
                    break;
            }

            System.Runtime.InteropServices.Marshal.Copy(rgbValues, 0, bitmapData.Scan0, length);
            image.UnlockBits(bitmapData);
&lt;/pre&gt;

&lt;p&gt;The two calls to Marshal.Copy copies the image data to an array that we can manipulate and then copies it back into the image.&lt;/p&gt;

&lt;p&gt;And FastComputePixel doesn&amp;#8217;t have to make any calls to the Bitmap object.&lt;/p&gt;

&lt;pre class=&#34;brush: csharp; title: ; notranslate&#34; title=&#34;&#34;&gt;private static bool FastComputePixel(byte[] rgbValues, byte b, int c, int pixelsPerChar, int bytesPerPixel)
        {
            var partial = b/pixelsPerChar;
            var last = b - (partial*(pixelsPerChar-1));
            var partialBytes = Enumerable.Repeat(partial, pixelsPerChar - 1).ToList();
            partialBytes.Add(last);
            for (var i = 0; i &amp;lt; pixelsPerChar; i++)
            {
                var pixel = ((c*pixelsPerChar) + i)*bytesPerPixel;
                if (pixel &amp;gt;= rgbValues.Length)
                    return false;

                var red = rgbValues[pixel];
                var blue = rgbValues[pixel + 2];

                var green = (red + blue)/2;
                if (green &amp;gt;= 128)
                    green -= partialBytes[i];
                else
                    green += partialBytes[i];

                rgbValues[pixel + 1] = (byte)green;
            }
            return true;
        }
&lt;/pre&gt;

&lt;p&gt;We just call LockBits, manipulate the image data array, and UnlockBits.&lt;/p&gt;

&lt;p&gt;You should notice the application is much more responsive!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Image Processing Part 1</title>
      <link>http://thewizardsmanse.com/image-processing-part-1/</link>
      <pubDate>Fri, 23 Nov 2012 04:16:04 +0000</pubDate>
      
      <guid>http://thewizardsmanse.com/image-processing-part-1/</guid>
      <description>&lt;p&gt;This is, hopefully, the first in a series of posts using this codebase. The topics will be varied, but hopefully the codebase will tie them together&amp;#8230;&lt;/p&gt;

&lt;p&gt;Can you tell what is different between this image:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://thewizardsmanse.com/2012/11/Redbud.JPG&#34;&gt;&lt;img class=&#34;size-full wp-image-30 aligncenter&#34; title=&#34;Redbud&#34; src=&#34;http://thewizardsmanse.com/2012/11/Redbud.jpg&#34; alt=&#34;Origional Redbud image&#34; width=&#34;300&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;and this one:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://thewizardsmanse.com/2012/11/Redbud2.bmp&#34;&gt;&lt;img class=&#34;aligncenter size-full wp-image-31&#34; title=&#34;Redbud2&#34; src=&#34;http://thewizardsmanse.com/2012/11/Redbud2.jpg&#34; alt=&#34;Modified Redbud Image&#34; width=&#34;300&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Aside from the obvious visual differences, there is an important, hidden difference. You can click-through and grab the original versions and try to figure it out.&lt;/p&gt;

&lt;p&gt;The answer is below&amp;#8230;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;I was reading a story in &lt;a href=&#34;http://www.asimovs.com&#34; target=&#34;_blank&#34;&gt;Asimovs&lt;/a&gt; a while back (for the life of me, I cannot rember the name or month) where the charactors encoded messages by manipulating the pixels of an image. I thought that was an interesting idea, and decided to try it as a proof of concept.&lt;/p&gt;

&lt;p&gt;I created a project that opens an image, encodes some text into the image, and saves the result. It can also open the resulting image, decode the text, and display it. Notice that I said it &lt;strong&gt;encodes&lt;/strong&gt; the text and not &lt;strong&gt;encrypts&lt;/strong&gt; there is a big difference, and that will be handled later. By merely encoding the text, anyone who knows the algorithm can decode and read the text. The text encoded in the image is no different from text encoded as ASCII or Unicode. It is just an electronic representation of text. The idea here is to use &lt;a href=&#34;http://en.wikipedia.org/wiki/Security_through_obscurity&#34; target=&#34;_blank&#34;&gt;security through obscurity&lt;/a&gt;. Anyone seeing the output image by itself should find no obvious signs of an encoded message.&lt;/p&gt;

&lt;p&gt;I grabbed a copy of _&lt;a href=&#34;http://www.gutenberg.org/ebooks/12&#34; target=&#34;_blank&#34;&gt;Through the Looking Glass&lt;/a&gt;_ from Project Gutenberg and encoded it into the image above. I accomplish this by manipulating the green value of each pixel. Perhaps for this image it would be better to use the blue value&amp;#8230;&lt;/p&gt;

&lt;p&gt;Here&amp;#8217;s a look at the code:&lt;/p&gt;

&lt;p&gt;First, I need to assign a numeric value to the text that I wish to encode. I use an ASCII encoded to convert the text to a byte array:&lt;/p&gt;

&lt;pre class=&#34;brush: csharp; title: ; notranslate&#34; title=&#34;&#34;&gt;public static void Encode(Bitmap image, string text, int pixelsPerByte) 
{
  var bytes = new ASCIIEncoding().GetBytes(text);
  Encode(image, bytes, pixelsPerByte); 
}
&lt;/pre&gt;

&lt;p&gt;Because C# uses one byte for each channel of a pixel (red, green, blue, and alpha) and one byte for each character in ASCII text we could simply encode the text directly as an image. This, of course, would nullify our security through obscurity because it wouldn&amp;#8217;t appear to be a real image. Through experimentation, I found that manipulating only one channel to be best. I also don&amp;#8217;t want to completely overwrite an entire channel with a full byte of text, so I split each character across multiple pixels:&lt;/p&gt;

&lt;pre class=&#34;brush: csharp; title: ; notranslate&#34; title=&#34;&#34;&gt;public static void Encode(Bitmap image, byte[] bytes, int pixelsPerByte) 
{
  var totalBytes = image.Height*image.Width/pixelsPerByte;
  if(totalBytes &amp;lt; bytes.Length)
    throw new ApplicationException(&#34;Image too small to encode text.&#34;);
 
  var byteList = bytes.ToList();
  byteList.AddRange(Enumerable.Repeat((byte)0, totalBytes - bytes.Length));
  byteList.Add(0);
 
  for (var c = 0; c &amp;lt; byteList.Count; c++)
  {
    if (ComputePixel(image, byteList, c, pixelsPerByte))
      break;
  }
}
&lt;/pre&gt;

&lt;p&gt;Again, through experimentation, I found that 32 pixels per caracter works well.&lt;/p&gt;

&lt;p&gt;My method for encoding the data is to average the red and blue channels together and assign that value to the green channel. I then take my partial byte of text and either add it to or subtract it from the green channel.&lt;/p&gt;

&lt;pre class=&#34;brush: csharp; title: ; notranslate&#34; title=&#34;&#34;&gt;private static bool ComputePixel(Bitmap image, IReadOnlyList&amp;lt;byte&amp;gt; bytes, int c, int pixelsPerByte)
{
  var b = bytes;
  var partial = b/pixelsPerByte;
  var last = b - (partial*(pixelsPerByte-1));
  var partialBytes = Enumerable.Repeat(partial, pixelsPerByte - 1).ToList();
  partialBytes.Add(last);
  for (var i = 0; i &amp;lt; pixelsPerByte; i++)
  {
    var x = ((c * pixelsPerByte) + i) % image.Width;
    var y = ((c * pixelsPerByte) + i) / image.Width;
    if (y &amp;lt;= image.Height) 
      return true; 
    var color = image.GetPixel(x, y);
    var green = (color.R + color.B)/2;
    
    if (green &amp;gt;= 128)
      green -= partialBytes[i];
    else
      green += partialBytes[i];
    
    color = Color.FromArgb(color.A, color.R, green, color.B);
    image.SetPixel(x, y, color);
  }
  return false; 
}
&lt;/pre&gt;

&lt;p&gt;This algorithm is reversible, which is very handy if you want to decode the text&amp;#8230;&lt;/p&gt;

&lt;p&gt;You may have noticed that the modified image was rather large. That is because we must save the image in a way that doesn&amp;#8217;t modify the bits. .net makes saving the image easy, but using any of the other format will destroy the encoded text when the image is compressed.&lt;/p&gt;

&lt;pre class=&#34;brush: csharp; title: ; notranslate&#34; title=&#34;&#34;&gt;private void SaveToolStripMenuItemClick(object sender, EventArgs e)
{
  if (saveFileDialog1.ShowDialog() == DialogResult.OK)
    ((EncoderModel) encoderModelBindingSource.Current).Image.Save(saveFileDialog1.FileName, ImageFormat.MemoryBmp);
}
&lt;/pre&gt;

&lt;p&gt;The challenge to you is to create another algorithm that produces a better looking image, while still remaining reversible.&lt;/p&gt;

&lt;p&gt;You can download the code from the main branch of my gitHub repository: &lt;a href=&#34;https://github.com/nathanrobinson/ImageTextEncoder&#34; target=&#34;_blank&#34;&gt;nathanrobinson/ImageTextEncoder&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Then alter ComputePixel and ComputeByte to encode and decode the text. Some ideas would be to use Hue, Saturation, and Value, instead of Red, Green, and Blue; convert the image from color to grayscale; or something completely different.&lt;/p&gt;

&lt;p&gt;Let me know what cool ideas you come up with.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>