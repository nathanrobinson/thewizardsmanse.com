<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on The Wizard&#39;s Manse</title>
    <link>http://thewizardsmanse.com/tags/javascript/index.xml</link>
    <description>Recent content in Javascript on The Wizard&#39;s Manse</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2017 The Wizard&#39;s Manse.</copyright>
    <atom:link href="http://thewizardsmanse.com/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Automatic Paging with Knockout data-bindings</title>
      <link>http://thewizardsmanse.com/automatic-paging-with-knockout-data-bindings/</link>
      <pubDate>Tue, 03 Sep 2013 20:55:38 +0000</pubDate>
      
      <guid>http://thewizardsmanse.com/automatic-paging-with-knockout-data-bindings/</guid>
      <description>&lt;p&gt;I&amp;#8217;ve been a heavy user of &lt;a title=&#34;Knockout JS&#34; href=&#34;http://knockoutjs.com/&#34; target=&#34;_blank&#34;&gt;Knockout JS&lt;/a&gt; and MVVM with JavaScript for over a year and I&amp;#8217;ve found most designs can be achieved with the basic data-bindings. There are two scenarios that I have found which require specialized bindings. The first is a select box with numerous options. The second is a long list of data that doesn&amp;#8217;t fit on a single screen.&lt;/p&gt;

&lt;p&gt;I prefer to use the &lt;a title=&#34;chosen jQuery plugin&#34; href=&#34;http://harvesthq.github.io/chosen/&#34; target=&#34;_blank&#34;&gt;chosen jQuery plugin&lt;/a&gt; to manage unwieldy select boxes. The problem is combining the jQuery plugin with Knockout data-binding. For this I use a &lt;a title=&#34;Knockout Binding Extension For Chosen&#34; href=&#34;http://www.nuget.org/packages/cb.ko.binding.chosen/&#34; target=&#34;_blank&#34;&gt;Knockout Binding Extension For Chosen&lt;/a&gt;. One caveat on this binding is that it can take a while to bind. If you have multiple select boxes with large amounts of data displaying dynamically, you can notice a significant delay. I ran into this problem when binding to an editable grid. The entire grid would display with the select boxes hidden until the user selects that row for editing. The grid would lag by up to 10 seconds while all the select boxes rendered using the chosen plugin. To speed up the grid I wrapped each select box in a span with an &amp;#8220;if&amp;#8221; binding. This kept the select boxes from rendering until the user actually edited that row. Since only one row&amp;#8217;s worth of select boxes were being rendered instead of all rows, the delay wasn&amp;#8217;t as noticeable.&lt;/p&gt;

&lt;p&gt;The long list of data that doesn&amp;#8217;t fit on a single screen is a much different problem. To solve this I wanted a paging solution similar to the &lt;a title=&#34;Data Tables plugin&#34; href=&#34;https://datatables.net/&#34; target=&#34;_blank&#34;&gt;data tables plugin for jQuery&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a title=&#34;Data Tables&#34; href=&#34;http://screencast.com/t/2ZJlLiT6j&#34; target=&#34;_blank&#34;&gt;&lt;img class=&#34;embeddedObject&#34; alt=&#34;&#34; src=&#34;http://content.screencast.com/users/NathanJRobinson/folders/Jing/media/a81333be-7527-49b9-a5c4-fd9a26a8a0cb/2013-09-02_1711-thumb.png&#34; width=&#34;400&#34; height=&#34;162&#34; border=&#34;0&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The important functionality that I wanted were the ability to change the page size, the page links, and of course, the actual paging. Originally, I started out building the paging mechanics directly into my view models, but this created a lot of duplication both in the view model and in the html. My next step was to pull the paging functions out of the view model and put them into a base model that could extend any view model with paging functionality. It turns out the paging functionality is easy to encapsulate; for any paged list, you need to track the current page, the number of items per page, and the total number of items. From there it&amp;#8217;s fairly simple to calculate the items to display on the current page.&lt;/p&gt;

&lt;pre class=&#34;brush: jscript; title: ; notranslate&#34; title=&#34;&#34;&gt;self.page = ko.observable(1);

    self.itemsPerPage = ko.observable(10);

    self.totalPages = ko.computed(function () {
                var array = observableArray();
                return Math.ceil(array.length / self.itemsPerPage());
            });

    self.pagedItems = ko.computed(function () {
                var array = observableArray();
                var indexOfFirstItemOnCurrentPage = (((self.page() * 1) - 1) * (self.itemsPerPage() * 1));
                var pageArray = array.slice(indexOfFirstItemOnCurrentPage, indexOfFirstItemOnCurrentPage + (self.itemsPerPage()* 1));
                return pageArray;
            });
&lt;/pre&gt;

&lt;p&gt;The problem of repeating the html for the knockout binding isn&amp;#8217;t solved with a view model, though. What I really wanted was a drop-in replacement for the foreach binding that would work on any list and would wrap up all the paging functionality. There is a &lt;a title=&#34;SimpleGrid&#34; href=&#34;https://github.com/knockout/knockout/tree/gh-pages/examples/resources&#34; target=&#34;_blank&#34;&gt;SimpleGrid&lt;/a&gt; knockout binding that does paging, but it replaces the current html node with its own idea of how your data should be rendered. I wanted to use the inline template that the foreach binding uses so that I could page a table, an un-ordered list, or a bunch of divs. In order to be a true drop-in replacement for foreach, I had to separate out the three elements of the pager: the page size control, the paged items, and the page links. I call my pager binding like so:&lt;/p&gt;

&lt;pre class=&#34;brush: xml; title: ; notranslate&#34; title=&#34;&#34;&gt;&amp;lt;div id=&#34;testBinding&#34;&amp;gt;
            &amp;lt;div data-bind=&#34;pageSizeControl: observableArray, pageSize: pageSize&#34;&amp;gt;&amp;lt;/div&amp;gt;
            &amp;lt;table&amp;gt;
                &amp;lt;thead&amp;gt;
                    &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;$index&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Key&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Value&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Page Size&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
                &amp;lt;/thead&amp;gt;
                &amp;lt;tbody data-bind=&#34;pagedForeach: observableArray&#34;&amp;gt;
                    &amp;lt;tr&amp;gt;
                        &amp;lt;td data-bind=&#34;text: $index&#34;&amp;gt;&amp;lt;/td&amp;gt;
                        &amp;lt;td data-bind=&#34;text: key&#34;&amp;gt;&amp;lt;/td&amp;gt;
                        &amp;lt;td data-bind=&#34;text: value&#34;&amp;gt;&amp;lt;/td&amp;gt;
                        &amp;lt;td class=&#34;parentPageSize&#34; data-bind=&#34;text: $parent.pageSize&#34;&amp;gt;&amp;lt;/td&amp;gt;
                    &amp;lt;/tr&amp;gt;
                &amp;lt;/tbody&amp;gt;
            &amp;lt;/table&amp;gt;
            &amp;lt;div data-bind=&#34;pageLinks: observableArray&#34;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;I have four bindings that I can choose from which give me detailed control over the paging while also letting me reuse the code in a modular way.&lt;/p&gt;

&lt;pre&gt;pagedForeach: displays the current page of items
    pageLinks: displays the first page, last page, and page number navigation links
    pageSizeControl: displays a select box with four standard page sizes to choose from
    pageSize: lets your view model control the page size directly
&lt;/pre&gt;

&lt;p&gt;I checked in the binding to github as &lt;a href=&#34;https://github.com/nathanrobinson/knockout.pager&#34; title=&#34;knockout.pager&#34; target=&#34;_blank&#34;&gt;knockout.pager&lt;/a&gt;. I then used &lt;a href=&#34;http://www.myget.org/&#34; title=&#34;myGet&#34; target=&#34;_blank&#34;&gt;myGet &lt;/a&gt;to package the files and upload them to &lt;a href=&#34;http://www.nuget.org/packages/knockout.pager/&#34; title=&#34;knockout.pager&#34; target=&#34;_blank&#34;&gt;nuGet&lt;/a&gt;. I also built several &lt;a href=&#34;https://rawgithub.com/nathanrobinson/knockout.pager/master/tests.html&#34; title=&#34;unit tests&#34; target=&#34;_blank&#34;&gt;unit tests&lt;/a&gt;. One thing you may notice is that in my bindings I attach the paging view model to the array. This is because the other bindings can see the same view model. In order to work correctly, the bindings have to interact with the same view model. Rather than calling the foreach binding from my binding, I looked at the knockout source and so that foreach is simply a wrapper for the template binding, so I call the template binding directly. I also used the same method of generating templates for the page links and pager size controls that the SimpleGrid binding used.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fun with knockout.js</title>
      <link>http://thewizardsmanse.com/fun-with-knockout-js/</link>
      <pubDate>Mon, 04 Mar 2013 03:49:19 +0000</pubDate>
      
      <guid>http://thewizardsmanse.com/fun-with-knockout-js/</guid>
      <description>&lt;p&gt;A while ago I started looking into &lt;a title=&#34;knockout.js&#34; href=&#34;http://knockoutjs.com/&#34; target=&#34;_blank&#34;&gt;knockout.js&lt;/a&gt; for an internal MVC website that I&amp;#8217;m working on. Originally I was trying to solve the problem of a very large DOM that only displays a fraction of itself at any time. Knockout handles this very nicely with it&amp;#8217;s &lt;a title=&#34;if binding&#34; href=&#34;http://knockoutjs.com/documentation/if-binding.html&#34; target=&#34;_blank&#34;&gt;if binding&lt;/a&gt;. The more I used knockout, however, the more I fell in love with the &lt;a title=&#34;MVVM&#34; href=&#34;http://en.wikipedia.org/wiki/Model_View_ViewModel&#34; target=&#34;_blank&#34;&gt;MVVM pattern&lt;/a&gt;. In fact, if xaml bindings were as easy as knockout bindings, I wouldn&amp;#8217;t be so hesitant to jump into WPF programming!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The power of MVVM is the ability to have your view model handle your logic in code without having the complex interaction with your html DOM that is required by jQuery. As an example, I recreated a jQuery &lt;a href=&#34;http://www.datatables.net/&#34; target=&#34;_blank&#34;&gt;DataTable&lt;/a&gt; using only &lt;a href=&#34;http://jsfiddle.net/vdrzv/4/&#34; target=&#34;_blank&#34;&gt;knockout bindings&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One typical need when using MVVM is to take action on the UI when a value is updated. I have two scenarios and four different binding strategies in this &lt;a title=&#34;jsFiddle&#34; href=&#34;http://jsfiddle.net/W2heu/&#34; target=&#34;_blank&#34;&gt;example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the first two bindings we will validate that the text entered is numeric. If it isn&amp;#8217;t, then an error will be displayed to the user until the entry is corrected. In the last two bindings, the entry will be validated and invalid entries will be immediately replaced with &amp;#8220;0&amp;#8221;.&lt;/p&gt;

&lt;p&gt;The first binding will be the most familiar to users of jQuery. When your model is tightly coupled with your UI, you create events that fire when the user interacts with a DOM node and then do some action inside that event. In jQuery, validating user input would look something like this:&lt;/p&gt;

&lt;pre class=&#34;brush: jscript; title: ; notranslate&#34; title=&#34;&#34;&gt;$(&#39;input&#39;).on(&#39;change&#39;, function(){
    if(isInvalid(this.val()))
        handleInvalidValues(this);
});
&lt;/pre&gt;

&lt;p&gt;The equivalent in knockout is:&lt;/p&gt;

&lt;pre class=&#34;brush: xml; title: ; notranslate&#34; title=&#34;&#34;&gt;&amp;lt;input type=&#34;text&#34; data-bind=&#34;value: number1, valueUpdate: &#39;afterkeydown&#39;, event: { change: validateNumber1 }, css: { error : !number1valid() }&#34; /&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre class=&#34;brush: jscript; title: ; notranslate&#34; title=&#34;&#34;&gt;self.number1 = ko.observable(0);
 self.number1valid = ko.observable(true);
 self.validateNumber1 = function () {
 self.number1valid(!isNaN(self.number1()));
 };
&lt;/pre&gt;

&lt;p&gt;the &amp;#8220;event: { change: validateNumber1 }&amp;#8221; calls the validateNumber1 function on your ViewModel whenever the input is changed.&lt;/p&gt;

&lt;p&gt;In Test 1 in the &lt;a title=&#34;jsFiddle&#34; href=&#34;http://jsfiddle.net/W2heu/&#34; target=&#34;_blank&#34;&gt;example fiddle&lt;/a&gt;, the update doesn&amp;#8217;t occur until you leave the textbox. To make better use of the MVVM pattern, you have to stop thinking about the UI controlling the flow of you model and start envisioning the ViewModel controlling the flow of your UI. Knockout will do all the work of updating your ViewModel based on user input and will update you UI based on what your ViewModel does with that input. This makes for some very powerful and simple design even sans jQuery.&lt;/p&gt;

&lt;p&gt;Compare the performance of Test 1 with Test 2. Test 2 immediately displays an error message when an invalid character is typed and immediately removes the error when the input is corrected. Knockout does all the heavy lifting for us. All we do is define what is valid by using a computed observable function. As soon as our observable is updated, knockout checks the computed observables that are dependent on it and updates the UI if they change. No events need to be fired. No special methods need to be called. And the update is immediate.&lt;/p&gt;

&lt;pre class=&#34;brush: jscript; title: ; notranslate&#34; title=&#34;&#34;&gt;self.number2 = ko.observable(0);
    self.number2valid = ko.computed(function () {
        return !isNaN(self.number2());
&lt;/pre&gt;

&lt;p&gt;As you can see, the code is much simpler, too.&lt;/p&gt;

&lt;p&gt;C# programmers may recognize the third binding style as a property with a backing field.&lt;/p&gt;

&lt;pre class=&#34;brush: jscript; title: ; notranslate&#34; title=&#34;&#34;&gt;self._number3 = ko.observable(0);
    self.number3 = ko.computed({
        read: function () {
            return self._number3();
        },
        write: function (value) {
            self._number3(value);
            if (isNaN(value)) self._number3(0);
        },
        owner: self
    });
&lt;/pre&gt;

&lt;p&gt;We use the computed to intercept, validate, and possibly modify the incoming value. The odd part about updating the backing field before validating is an artifact of how knockout updates the ui. If we set _number3 to 0 when the incoming value was invalid (say &amp;#8220;0G&amp;#8221; for example) if _number3 was already 0, then knockout will not see a need to update the ui. This will leave what the user typed in the text box. To work around this, we set _number3 to whatever the user entered and then if it&amp;#8217;s invalid, we set it to 0, so knockout will immediately update the text box value back to 0.&lt;/p&gt;

&lt;p&gt;The final binding monitors the input in a simpler fashion.&lt;/p&gt;

&lt;pre class=&#34;brush: jscript; title: ; notranslate&#34; title=&#34;&#34;&gt;self.number4 = ko.observable(0);
    self.number4.subscribe(function () {
        if (isNaN(self.number4())) self.number4(0);
    });
&lt;/pre&gt;

&lt;p&gt;Instead of intercepting the value, we subscribe to the observable and validate on any change. We don&amp;#8217;t require an extra backing field, and the code is much simpler. Both Test 3 and Test 4 work equally well, but Test 4 is simpler to understand and code.&lt;/p&gt;

&lt;p&gt;While all 4 examples work, Test 1 is too dependent on the ui bindings to be a good implementation of MVVM. If you don&amp;#8217;t add the event binding to call your validation function, then none of your validation will happen. The method used in Test 2 is simpler to understand and more reliable because validation will always happen automatically. Test 3 is an example of carryover from a C# mindset and doesn&amp;#8217;t take full advantage of the power of the knockout implementation of MVVM. It&amp;#8217;s OK to subscribe to your ow properties and can greatly simplify your ViewModel.&lt;/p&gt;

&lt;p&gt;I hope this little look into the knockout MVVM library. I really dig it and look forward to using it more.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>My first rant…</title>
      <link>http://thewizardsmanse.com/my-first-rant/</link>
      <pubDate>Sat, 10 Nov 2012 05:09:05 +0000</pubDate>
      
      <guid>http://thewizardsmanse.com/my-first-rant/</guid>
      <description>&lt;p&gt;A friend sent me a &lt;a href=&#34;http://elm-lang.org/learn/Escape-from-Callback-Hell.elm&#34;&gt;page about elm&lt;/a&gt;. It bemoans the idea of &amp;#8220;Callback Hell&amp;#8221; and purports to resolve the situation with a completely new language for web scripting&amp;#8230; It didn&amp;#8217;t take me long to feel the urge to violently disagree with the premise of the page. The author compares callbacks to &amp;#8220;goto&amp;#8221; statements.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A callback is simply a function, anonymous or named, that is passed into another method to be called later. jQuery loves callbacks, but my first exposure to them was in c++.&lt;/p&gt;

&lt;p&gt;Here&amp;#8217;s an example:&lt;/p&gt;

&lt;pre class=&#34;brush: jscript; title: ; notranslate&#34; title=&#34;&#34;&gt;function Method1(callback){
    ...
    callback(someValue);
}

function Method2(myValue){
    ...
}

Method1(Method2);
&lt;/pre&gt;

&lt;p&gt;The thing to keep in mind is that modern languages have &amp;#8220;anonymous&amp;#8221; methods, so you wouldn&amp;#8217;t need to declare Method2..&lt;/p&gt;

&lt;pre class=&#34;brush: jscript; title: ; notranslate&#34; title=&#34;&#34;&gt;function Method1(callback){
    ...
    callback(someValue);
}

Method1(function(myValue){...});
&lt;/pre&gt;

&lt;p&gt;So, what&amp;#8217;s wrong with the stance that callbacks are unreadable?&lt;/p&gt;

&lt;p&gt;I don&amp;#8217;t know&amp;#8230; just the fact that they aren&amp;#8217;t. Especially the example that he gives:&lt;/p&gt;

&lt;pre class=&#34;brush: jscript; title: ; notranslate&#34; title=&#34;&#34;&gt;function getPhoto(tag, handlerCallback) {
    asyncGet(requestTag(tag), function(photoList) {
        asyncGet(requestOneFrom(photoList), function(photoSizes) {
            handlerCallback(sizesToPhoto(photoSizes));
        });
    });
}

getPhoto(&#39;tokyo&#39;, drawOnScreen);
&lt;/pre&gt;

&lt;p&gt;I personally find that much more readable than his alternative:&lt;/p&gt;

&lt;pre class=&#34;brush: plain; title: ; notranslate&#34; title=&#34;&#34;&gt;getPhotos = lift sizesToPhoto . send . lift requestOneFrom . send . lift requestTag

(tagInput, tags) = Input.textField &#34;Flickr Instant Search&#34;

scene (w,h) img = flow down [ container w 60 middle tagInput, container w (h - 100) middle img ]

main = lift2 scene Window.dimensions(images (getPhotos (dropRepeats tags)))
&lt;/pre&gt;

&lt;p&gt;especially given all the helper methods that he includes&amp;#8230;&lt;/p&gt;

&lt;p&gt;I certainly don&amp;#8217;t think that callbacks should be singled out and compared to &amp;#8220;goto&amp;#8221;. Really, any function call is a glorified &amp;#8220;goto&amp;#8221;; they just have pretty curly braces to set them apart.&lt;/p&gt;

&lt;p&gt;I can&amp;#8217;t help but wonder if &amp;#8220;goto&amp;#8221; would have gotten such a bad wrap if the old text editors would have had shift-F12 support. I, for one, always regret never having the chance to use &amp;#8220;comefrom&amp;#8221;.&lt;/p&gt;

&lt;p&gt;As anyone who works on enterprise level applications knows, code is messy. Especially when the bosses don&amp;#8217;t care what it looks like, just how quickly you can write it. That&amp;#8217;s why modern IDEs arose, because it&amp;#8217;s easier to build a program to navigate your code for you, than to write code that&amp;#8217;s easier to navigate.&lt;/p&gt;

&lt;p&gt;So, you can go to great lengths, even writing new languages, to avoid using callbacks, or you could use them in a way that makes them easy to understand.&lt;/p&gt;

&lt;p&gt;In then end, what really matters to me is that I get to keep my curly braces.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>